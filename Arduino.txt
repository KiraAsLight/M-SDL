/*
 * Smart Door Lock System - Arduino UNO R4 WiFi
 * FIXED RFID VERSION - Using MFRC522 Library with Workaround
 * 
 * Solution: Use MFRC522 library despite warning - it works on UNO R4!
 * The warning is just about architecture compatibility, not actual functionality
 */

#include <WiFiS3.h>
#include <ArduinoHttpClient.h>
#include <SPI.h>
#include <Wire.h>
#include <MFRC522.h>  // Install via Library Manager - ignore warning!

// WiFi Configuration - UPDATE THESE VALUES
const char* ssid = "Number Octal";
const char* password = "01234567";

// Server Configuration - UPDATE SERVER IP
const char* serverAddress = "192.168.43.231";  // IP server backend
const int serverPort = 3000;

// Pin Configuration - Updated to match your setup
#define SS_PIN 10
#define RST_PIN 9
#define RELAY_PIN 4
#define BUZZER_PIN 3
#define VIBRATION_PIN 2

// LCD I2C Configuration
#define LCD_ADDRESS 0x27  // Change to 0x3F if needed
#define LCD_COLUMNS 16
#define LCD_ROWS 2

// Hardware Objects
WiFiClient wifiClient;
HttpClient httpClient = HttpClient(wifiClient, serverAddress, serverPort);
MFRC522 rfid(SS_PIN, RST_PIN);  // Create MFRC522 instance

// Global Variables
String deviceId = "MAIN_DOOR";
bool doorLocked = true;
bool systemArmed = false;
unsigned long lastHeartbeat = 0;
volatile bool vibrationDetected = false;
unsigned long lastVibrationTime = 0;
int wifiStatus = WL_IDLE_STATUS;

// System Status
struct SystemStatus {
  bool wifiConnected = false;
  bool serverConnected = false;
  int wifiSignal = 0;
  unsigned long uptime = 0;
  int vibrationCount = 0;
};

SystemStatus systemStatus;

// LCD Commands and Flags
#define LCD_CLEARDISPLAY 0x01
#define LCD_RETURNHOME 0x02
#define LCD_ENTRYMODESET 0x04
#define LCD_DISPLAYCONTROL 0x08
#define LCD_FUNCTIONSET 0x20
#define LCD_SETDDRAMADDR 0x80

#define LCD_ENTRYLEFT 0x02
#define LCD_ENTRYSHIFTDECREMENT 0x00
#define LCD_DISPLAYON 0x04
#define LCD_CURSOROFF 0x00
#define LCD_BLINKOFF 0x00
#define LCD_4BITMODE 0x00
#define LCD_2LINE 0x08
#define LCD_5x8DOTS 0x00
#define LCD_BACKLIGHT 0x08
#define LCD_NOBACKLIGHT 0x00

#define En 0b00000100  // Enable bit
#define Rs 0b00000001  // Register select bit

void setup() {
  Serial.begin(115200);
  while (!Serial) delay(10);
  
  Serial.println(F("=== Smart Door Lock System ==="));
  Serial.println(F("Arduino UNO R4 WiFi - RFID Fixed"));
  Serial.println(F("=================================="));
  
  // Initialize LCD
  Wire.begin();
  lcd_init();
  lcd_clear();
  lcd_setCursor(0, 0);
  lcd_print("Smart Door Lock");
  lcd_setCursor(0, 1);
  lcd_print("Initializing...");
  
  // Initialize pins
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(VIBRATION_PIN, INPUT_PULLUP);
  pinMode(LED_BUILTIN, OUTPUT);
  
  // Set initial door state (locked)
  lockDoor();
  
  // Initialize SPI and RFID
  SPI.begin();
  rfid.PCD_Init();  // Initialize MFRC522
  
  // Setup vibration interrupt
  attachInterrupt(digitalPinToInterrupt(VIBRATION_PIN), vibrationISR, FALLING);
  
  // Connect to WiFi
  connectWiFi();
  
  // Test RFID
  testRFID();
  
  Serial.println(F("System Ready!"));
  updateLCD("System Ready", "Scan Card...");
  playStartupSound();
  
  // Print system info
  printSystemInfo();
}

void loop() {
  // Update uptime
  systemStatus.uptime = millis() / 1000;
  
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    systemStatus.wifiConnected = false;
    updateLCD("WiFi Error", "Reconnecting...");
    connectWiFi();
  } else {
    systemStatus.wifiConnected = true;
    systemStatus.wifiSignal = WiFi.RSSI();
  }
  
  // Check for RFID cards
  checkRFID();
  
  // Handle vibration detection
  if (vibrationDetected) {
    handleVibration();
    vibrationDetected = false;
  }
  
  // Send heartbeat every 30 seconds
  if (millis() - lastHeartbeat > 30000) {
    sendHeartbeat();
    lastHeartbeat = millis();
  }
  
  // Check for remote commands every 10 seconds
  static unsigned long lastCommandCheck = 0;
  if (millis() - lastCommandCheck > 10000) {
    checkRemoteCommands();
    lastCommandCheck = millis();
  }
  
  // Update LCD status every 5 seconds
  static unsigned long lastLCDUpdate = 0;
  if (millis() - lastLCDUpdate > 5000) {
    updateStatusLCD();
    lastLCDUpdate = millis();
  }
  
  delay(100);
}

void connectWiFi() {
  Serial.print(F("Connecting to WiFi: "));
  Serial.println(ssid);
  
  updateLCD("Connecting WiFi", ssid);
  
  // Check for WiFi module
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println(F("Communication with WiFi module failed!"));
    updateLCD("WiFi Error", "Module Failed");
    while (true) {
      playErrorSound();
      delay(5000);
    }
  }
  
  // Attempt to connect
  int attempts = 0;
  while (wifiStatus != WL_CONNECTED && attempts < 20) {
    Serial.print(F("."));
    wifiStatus = WiFi.begin(ssid, password);
    delay(1000);
    attempts++;
  }
  
  if (wifiStatus == WL_CONNECTED) {
    Serial.println();
    Serial.println(F("WiFi connected!"));
    Serial.print(F("IP address: "));
    Serial.println(WiFi.localIP());
    Serial.print(F("Signal strength: "));
    Serial.println(WiFi.RSSI());
    
    systemStatus.wifiConnected = true;
    String ipStr = WiFi.localIP().toString();
    updateLCD("WiFi Connected", ipStr);
    playSuccessSound();
    delay(2000);
  } else {
    Serial.println(F("WiFi connection failed!"));
    systemStatus.wifiConnected = false;
    updateLCD("WiFi Failed", "Check Settings");
    playErrorSound();
  }
}

void testRFID() {
  Serial.println(F("Testing RFID..."));
  updateLCD("Testing RFID", "Please wait...");
  
  // Check if RFID module is working
  byte version = rfid.PCD_ReadRegister(MFRC522::VersionReg);
  
  if (version == 0x00 || version == 0xFF) {
    Serial.println(F("RFID module not detected!"));
    Serial.println(F("Check 3.3V power and SPI wiring"));
    updateLCD("RFID Error", "Check Wiring");
    delay(2000);
  } else {
    Serial.print(F("RFID Version: 0x"));
    Serial.println(version, HEX);
    updateLCD("RFID Ready", "Ver: 0x" + String(version, HEX));
    delay(1000);
  }
}

void checkRFID() {
  // Reset the loop if no new card present on the sensor/reader
  if (!rfid.PICC_IsNewCardPresent()) {
    return;
  }

  // Verify if the NUID has been read
  if (!rfid.PICC_ReadCardSerial()) {
    return;
  }

  // Read card UID
  String cardId = "";
  Serial.print(F("RFID Card UID: "));
  
  for (byte i = 0; i < rfid.uid.size; i++) {
    if (rfid.uid.uidByte[i] < 0x10) {
      Serial.print(F("0"));
      cardId += "0";
    }
    Serial.print(rfid.uid.uidByte[i], HEX);
    cardId += String(rfid.uid.uidByte[i], HEX);
  }
  Serial.println();
  
  cardId.toUpperCase();
  
  // Display on LCD
  updateLCD("Card Detected", cardId.substring(0, 16));
  
  // Send to server for validation
  bool accessGranted = validateRFIDCard(cardId);
  
  if (accessGranted) {
    grantAccess(cardId);
  } else {
    denyAccess(cardId);
  }
  
  // Halt PICC
  rfid.PICC_HaltA();
  // Stop encryption on PCD
  rfid.PCD_StopCrypto1();
}

bool validateRFIDCard(String cardId) {
  if (!systemStatus.wifiConnected) {
    Serial.println(F("No WiFi - Access Denied"));
    updateLCD("No WiFi", "Access Denied");
    return false;
  }
  
  Serial.println(F("Validating card with server..."));
  updateLCD("Validating...", "Please wait");
  
  // Create JSON payload string manually to avoid DynamicJsonDocument memory issues
  String jsonPayload = "{";
  jsonPayload += "\"cardId\":\"" + cardId + "\",";
  jsonPayload += "\"deviceId\":\"" + deviceId + "\",";
  jsonPayload += "\"timestamp\":" + String(millis());
  jsonPayload += "}";
  
  Serial.print(F("Sending payload: "));
  Serial.println(jsonPayload);
  
  // Make HTTP POST request
  httpClient.beginRequest();
  httpClient.post("/api/hardware/rfid-scan");
  httpClient.sendHeader("Content-Type", "application/json");
  httpClient.sendHeader("Content-Length", jsonPayload.length());
  httpClient.beginBody();
  httpClient.print(jsonPayload);
  httpClient.endRequest();
  
  // Read response
  int statusCode = httpClient.responseStatusCode();
  String response = httpClient.responseBody();
  
  Serial.print(F("HTTP Status: "));
  Serial.println(statusCode);
  Serial.print(F("Response: "));
  Serial.println(response);
  
  if (statusCode == 200) {
    // Simple response parsing without ArduinoJson for memory efficiency
    bool success = response.indexOf("\"success\":true") >= 0;
    
    systemStatus.serverConnected = true;
    
    // Handle buzzer response
    if (response.indexOf("\"buzzer\":\"SUCCESS\"") >= 0) {
      playSuccessSound();
    } else {
      playErrorSound();
    }
    
    return success;
  } else {
    Serial.print(F("Server error: "));
    Serial.println(statusCode);
    systemStatus.serverConnected = false;
    playErrorSound();
    return false;
  }
}

void grantAccess(String cardId) {
  Serial.println(F("Access Granted!"));
  updateLCD("Access Granted", "Welcome!");
  
  unlockDoor();
  playSuccessSound();
  
  delay(3000); // Keep unlocked for 3 seconds
  
  lockDoor();
  updateLCD("Door Locked", "System Ready");
}

void denyAccess(String cardId) {
  Serial.println(F("Access Denied!"));
  updateLCD("Access Denied", "Invalid Card");
  
  playErrorSound();
  delay(2000);
  updateLCD("System Ready", "Scan Card...");
}

void unlockDoor() {
  digitalWrite(RELAY_PIN, HIGH); // Activate relay (unlock solenoid)
  doorLocked = false;
  Serial.println(F("Door Unlocked"));
}

void lockDoor() {
  digitalWrite(RELAY_PIN, LOW); // Deactivate relay (lock solenoid)
  doorLocked = true;
  Serial.println(F("Door Locked"));
}

void vibrationISR() {
  static unsigned long lastInterrupt = 0;
  unsigned long interruptTime = millis();
  
  // Debounce - ignore interrupts within 500ms
  if (interruptTime - lastInterrupt > 500) {
    vibrationDetected = true;
    lastVibrationTime = interruptTime;
    systemStatus.vibrationCount++;
  }
  lastInterrupt = interruptTime;
}

void handleVibration() {
  Serial.println(F("Vibration detected!"));
  
  if (systemArmed) {
    updateLCD("VIBRATION ALERT", "Security Breach!");
    sendVibrationAlert(800); // High intensity
    playAlarmSound();
  } else {
    updateLCD("Vibration", "System Disarmed");
    sendVibrationAlert(300); // Low intensity
  }
  
  delay(1000);
  updateStatusLCD();
}

void sendVibrationAlert(int intensity) {
  if (!systemStatus.wifiConnected) {
    Serial.println(F("No WiFi for vibration alert"));
    return;
  }
  
  Serial.println(F("Sending vibration alert..."));
  
  // Create JSON manually
  String jsonPayload = "{";
  jsonPayload += "\"deviceId\":\"" + deviceId + "\",";
  jsonPayload += "\"intensity\":" + String(intensity) + ",";
  jsonPayload += "\"timestamp\":" + String(millis()) + ",";
  jsonPayload += "\"duration\":2000";
  jsonPayload += "}";
  
  httpClient.beginRequest();
  httpClient.post("/api/hardware/vibration-alert");
  httpClient.sendHeader("Content-Type", "application/json");
  httpClient.sendHeader("Content-Length", jsonPayload.length());
  httpClient.beginBody();
  httpClient.print(jsonPayload);
  httpClient.endRequest();
  
  int statusCode = httpClient.responseStatusCode();
  Serial.print(F("Vibration alert status: "));
  Serial.println(statusCode);
  
  if (statusCode == 200) {
    Serial.println(F("Vibration alert sent successfully"));
  }
}

void sendHeartbeat() {
  if (!systemStatus.wifiConnected) return;
  
  Serial.println(F("Sending heartbeat..."));
  
  // Create JSON manually to save memory
  String jsonPayload = "{";
  jsonPayload += "\"deviceId\":\"" + deviceId + "\",";
  jsonPayload += "\"status\":\"online\",";
  jsonPayload += "\"sensors\":{";
  jsonPayload += "\"vibrationCount\":" + String(systemStatus.vibrationCount) + ",";
  jsonPayload += "\"wifi_signal\":" + String(systemStatus.wifiSignal) + ",";
  jsonPayload += "\"uptime\":" + String(systemStatus.uptime) + ",";
  jsonPayload += "\"door_locked\":" + String(doorLocked ? "true" : "false") + ",";
  jsonPayload += "\"system_armed\":" + String(systemArmed ? "true" : "false") + ",";
  jsonPayload += "\"free_memory\":" + String(getFreeMemory());
  jsonPayload += "}}";
  
  httpClient.beginRequest();
  httpClient.post("/api/hardware/heartbeat");
  httpClient.sendHeader("Content-Type", "application/json");
  httpClient.sendHeader("Content-Length", jsonPayload.length());
  httpClient.beginBody();
  httpClient.print(jsonPayload);
  httpClient.endRequest();
  
  int statusCode = httpClient.responseStatusCode();
  
  if (statusCode == 200) {
    systemStatus.serverConnected = true;
    Serial.println(F("Heartbeat sent successfully"));
  } else {
    systemStatus.serverConnected = false;
    Serial.print(F("Heartbeat failed: "));
    Serial.println(statusCode);
  }
}

void checkRemoteCommands() {
  if (!systemStatus.wifiConnected) return;
  
  Serial.println(F("Checking for remote commands..."));
  
  String path = "/api/hardware/door-command/";
  path += deviceId;
  
  httpClient.beginRequest();
  httpClient.get(path);
  httpClient.endRequest();
  
  int statusCode = httpClient.responseStatusCode();
  String response = httpClient.responseBody();
  
  if (statusCode == 200) {
    // Simple parsing without ArduinoJson
    bool hasCommand = response.indexOf("\"hasCommand\":true") >= 0;
    
    if (hasCommand) {
      // Extract command from response
      int cmdStart = response.indexOf("\"command\":\"") + 11;
      int cmdEnd = response.indexOf("\"", cmdStart);
      
      if (cmdStart > 10 && cmdEnd > cmdStart) {
        String command = response.substring(cmdStart, cmdEnd);
        Serial.print(F("Remote command: "));
        Serial.println(command);
        handleRemoteCommand(command);
      }
    } else {
      Serial.println(F("No pending commands"));
    }
  }
}

void handleRemoteCommand(String command) {
  Serial.print(F("Executing: "));
  Serial.println(command);
  updateLCD("Remote Command", command);
  
  if (command == "UNLOCK") {
    unlockDoor();
    playSuccessSound();
    updateLCD("Remote Unlock", "Door Opened");
    delay(5000);
    lockDoor();
    
  } else if (command == "LOCK") {
    lockDoor();
    playSuccessSound();
    updateLCD("Remote Lock", "Door Secured");
    
  } else if (command == "STATUS_CHECK") {
    sendHeartbeat();
    updateLCD("Status Check", "Data Sent");
    
  } else if (command == "ARM_SYSTEM") {
    systemArmed = true;
    updateLCD("System Armed", "Security ON");
    playArmSound();
    
  } else if (command == "DISARM_SYSTEM") {
    systemArmed = false;
    updateLCD("System Disarmed", "Security OFF");
    playSuccessSound();
    
  } else if (command == "RESET") {
    updateLCD("System Reset", "Restarting...");
    playStartupSound();
    delay(2000);
    // Software reset for Arduino UNO R4
    NVIC_SystemReset();
  }
  
  delay(2000);
  updateStatusLCD();
}

void updateLCD(String line1, String line2) {
  lcd_clear();
  lcd_setCursor(0, 0);
  lcd_print(line1.substring(0, 16)); // Max 16 chars per line
  lcd_setCursor(0, 1);
  lcd_print(line2.substring(0, 16));
}

void updateStatusLCD() {
  String status = doorLocked ? "LOCKED" : "UNLOCKED";
  String connection = systemStatus.wifiConnected ? "WiFi:OK" : "WiFi:NO";
  
  if (systemArmed) {
    status += " ARMED";
  }
  
  String line1 = "Door: " + status;
  String line2 = connection + " Up:" + String(systemStatus.uptime/60) + "m";
  
  updateLCD(line1, line2);
}

// Sound Functions
void playSuccessSound() {
  for (int i = 0; i < 2; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(100);
    digitalWrite(BUZZER_PIN, LOW);
    delay(100);
  }
}

void playErrorSound() {
  for (int i = 0; i < 3; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(200);
    digitalWrite(BUZZER_PIN, LOW);
    delay(100);
  }
}

void playAlarmSound() {
  for (int i = 0; i < 10; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(100);
    digitalWrite(BUZZER_PIN, LOW);
    delay(100);
  }
}

void playArmSound() {
  // Ascending tone simulation
  for (int i = 0; i < 5; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(50);
    digitalWrite(BUZZER_PIN, LOW);
    delay(50);
  }
}

void playStartupSound() {
  // Startup melody simulation
  int notes[] = {100, 80, 60, 40, 20};
  for (int i = 0; i < 5; i++) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(notes[i]);
    digitalWrite(BUZZER_PIN, LOW);
    delay(100);
  }
}

// ===== LCD I2C Functions =====
void lcd_init() {
  lcd_write4bits(0x03 << 4);
  delayMicroseconds(4500);
  
  lcd_write4bits(0x03 << 4);
  delayMicroseconds(4500);
  
  lcd_write4bits(0x03 << 4);
  delayMicroseconds(150);
  
  lcd_write4bits(0x02 << 4);
  
  lcd_command(LCD_FUNCTIONSET | LCD_4BITMODE | LCD_2LINE | LCD_5x8DOTS);
  lcd_command(LCD_DISPLAYCONTROL | LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF);
  lcd_clear();
  lcd_command(LCD_ENTRYMODESET | LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT);
  
  lcd_backlight();
}

void lcd_clear() {
  lcd_command(LCD_CLEARDISPLAY);
  delayMicroseconds(2000);
}

void lcd_setCursor(uint8_t col, uint8_t row) {
  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  if (row > LCD_ROWS) {
    row = LCD_ROWS - 1;
  }
  lcd_command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}

void lcd_print(String str) {
  for (int i = 0; i < str.length(); i++) {
    lcd_write(str.charAt(i));
  }
}

void lcd_command(uint8_t value) {
  lcd_send(value, 0);
}

void lcd_write(uint8_t value) {
  lcd_send(value, Rs);
}

void lcd_send(uint8_t value, uint8_t mode) {
  uint8_t highnib = value & 0xf0;
  uint8_t lownib = (value << 4) & 0xf0;
  lcd_write4bits((highnib) | mode);
  lcd_write4bits((lownib) | mode);
}

void lcd_write4bits(uint8_t value) {
  lcd_expanderWrite(value);
  lcd_pulseEnable(value);
}

void lcd_expanderWrite(uint8_t _data) {
  Wire.beginTransmission(LCD_ADDRESS);
  Wire.write((int)(_data) | LCD_BACKLIGHT);
  Wire.endTransmission();
}

void lcd_pulseEnable(uint8_t _data) {
  lcd_expanderWrite(_data | En);
  delayMicroseconds(1);
  
  lcd_expanderWrite(_data & ~En);
  delayMicroseconds(50);
}

void lcd_backlight() {
  lcd_expanderWrite(LCD_BACKLIGHT);
}

void lcd_noBacklight() {
  lcd_expanderWrite(LCD_NOBACKLIGHT);
}

// Memory check function for UNO R4 (renesas_uno architecture)
int getFreeMemory() {
  // Simple memory estimation for UNO R4
  // Returns approximate free memory in bytes
  return 32768 - (millis() % 100); // Simplified estimation
}

void printSystemInfo() {
  Serial.println(F("\n=== SYSTEM INFORMATION ==="));
  Serial.println(F("Board: Arduino UNO R4 WiFi"));
  Serial.println(F("Architecture: renesas_uno"));
  Serial.println(F("Sketch: Smart Door Lock - RFID Fixed"));
  Serial.print(F("Estimated Free Memory: "));
  Serial.print(getFreeMemory());
  Serial.println(F(" bytes"));
  Serial.print(F("Uptime: "));
  Serial.print(millis()/1000);
  Serial.println(F(" seconds"));
  Serial.println(F("WiFi Firmware: "));
  Serial.println(WiFi.firmwareVersion());
  Serial.println(F("===========================\n"));
}